---
title: "utilities"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{geometries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#"
)
```

```{r setup}
library(geometries)
library(Rcpp)
```


You can include all utility functions through the main header

```r
#include "geometries/utils/utils.hpp"
```

Or include the specific ones you need

```r
#include "geometries/utils/columns/columns.hpp"
#include "geometries/utils/lines/lines.hpp"
#include "geometries/utils/lists/list.hpp"
#include "geometries/utils/matrix/matrix.hpp"
#include "geometries/utils/sexp/sexp.hpp"
#include "geometries/utils/subset/subset.hpp"
#include "geometries/utils/unique/unique_ids.hpp"
#include "geometries/utils/vectors/vectors.hpp"
```


### columns

The two functions in here are 

- `column_positions()` - Finds named columns in a matrix
- `other_columns()` - returns the 'other columns' not specified in the inputs

```{r}

cppFunction(
  depends = 'geometries'
  , includes = '#include "geometries/utils/columns/columns.hpp"'
  , code = '
    Rcpp::IntegerVector column_positions( SEXP x, Rcpp::StringVector cols ) {
      return geometries::utils::column_positions( x, cols );
    }
  '
)

m <- matrix(1:20, ncol = 4)
colnames( m ) <- c("x","y","z","m")

column_positions(m, "x")
column_positions(m, "y")
column_positions(m, c("z","m"))

```



```{r}

cppFunction(
  depends = 'geometries'
  , includes = '#include "geometries/utils/columns/columns.hpp"'
  , code = '
    SEXP other_columns( SEXP x, SEXP cols ) {
      return geometries::utils::other_columns( x, cols );
    }
  '
)


df <- data.frame(
  x = 1:5
  , y = 2:6
  , z = 3:7
  , m = 4:8
  , val = letters[1:5]
)

other_columns( df, c("x","y") )

```


### lines

The idea of `lines` is to get the position (index) in a vector where consecutive values begin and end.

The output is a matrix where the first column is the start index, and the second column is the end index

```{r}

## id positions
## 
## takes a sorted vector and returns the start & end indices of each unique element
cppFunction(
  depends = 'geometries'
  , includes = '#include "geometries/utils/lines/lines.hpp"'
  , code = '
    Rcpp::IntegerMatrix id_positions( SEXP x ) {
      return geometries::utils::id_positions( x );
    }
  '
)

( x <- c( rep(1, 5), rep(2, 10), rep(3, 6), rep(4, 2) ) )
id_positions( x )


```

### list

### matrix

### sexp

### subset

### unique

There is already a `Rcpp::unique()` functions, but this doesn't guarantee maintaining the original order of the input. So I've made my own version

```{r}

## Unique

## retains the original input order

cppFunction(
  depends = "geometries"
  , includes = '#include "geometries/utils/unique/unique_sort.hpp"'
  , code = '
    SEXP my_unique( SEXP x ) {
      return geometries::utils::get_sexp_unique( x );
    }
  '
)

## compare with
cppFunction(
  code = '
    Rcpp::NumericVector rcpp_unique( Rcpp::NumericVector x ) {
      return Rcpp::unique( x );
    }
  '
)

x <- c(1,1,1,3,3,4,4,2)

my_unique( x )
rcpp_unique( x )

```


### vectors






